import { h, defineComponent, computed, ref } from 'vue';
import { useConfig, useTheme } from '../../_mixins';
import { NBaseClose } from '../../_internal';
import { warn, createKey, call } from '../../_utils';
import { tagLight } from '../styles';
import commonProps from './common-props';
import style from './styles/index.cssr';
const tagProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), commonProps), { bordered: {
        type: Boolean,
        default: undefined
    }, checked: {
        type: Boolean,
        default: false
    }, checkable: {
        type: Boolean,
        default: false
    }, onClose: [Array, Function], onMouseenter: Function, onMouseleave: Function, 
    // eslint-disable-next-line vue/prop-name-casing
    'onUpdate:checked': {
        type: Function,
        default: undefined
    }, 
    // private
    internalStopClickPropagation: {
        type: Boolean,
        default: false
    }, 
    // deprecated
    onCheckedChange: {
        type: Function,
        validator: () => {
            if (process.env.NODE_ENV !== 'production') {
                warn('tag', '`on-checked-change` is deprecated, please use `on-update:checked` instead');
            }
            return true;
        },
        default: undefined
    } });
export default defineComponent({
    name: 'Tag',
    props: tagProps,
    setup(props) {
        const contentRef = ref(null);
        const { mergedBorderedRef, mergedClsPrefixRef } = useConfig(props);
        const themeRef = useTheme('Tag', 'Tag', style, tagLight, props, mergedClsPrefixRef);
        function handleClick(e) {
            if (!props.disabled) {
                if (props.checkable) {
                    const { checked, onCheckedChange, 'onUpdate:checked': onUpdateChecked } = props;
                    if (onUpdateChecked)
                        onUpdateChecked(!checked);
                    // deprecated
                    if (onCheckedChange)
                        onCheckedChange(!checked);
                }
            }
        }
        function handleCloseClick(e) {
            if (props.internalStopClickPropagation) {
                e.stopPropagation();
            }
            if (!props.disabled) {
                const { onClose } = props;
                if (onClose)
                    call(onClose);
            }
        }
        const tagPublicMethods = {
            setTextContent(textContent) {
                const { value } = contentRef;
                if (value)
                    value.textContent = textContent;
            }
        };
        return Object.assign(Object.assign({}, tagPublicMethods), { mergedClsPrefix: mergedClsPrefixRef, contentRef, mergedBordered: mergedBorderedRef, handleClick,
            handleCloseClick, cssVars: computed(() => {
                const { type, size } = props;
                const { common: { cubicBezierEaseInOut }, self: { padding, closeMargin, borderRadius, opacityDisabled, textColorCheckable, textColorHoverCheckable, textColorPressedCheckable, textColorChecked, colorCheckable, colorHoverCheckable, colorPressedCheckable, colorChecked, colorCheckedHover, colorCheckedPressed, [createKey('closeSize', size)]: closeSize, [createKey('fontSize', size)]: fontSize, [createKey('height', size)]: height, [createKey('color', type)]: color, [createKey('textColor', type)]: textColor, [createKey('border', type)]: border, [createKey('closeColor', type)]: closeColor, [createKey('closeColorHover', type)]: closeColorHover, [createKey('closeColorPressed', type)]: closeColorPressed } } = themeRef.value;
                return {
                    '--bezier': cubicBezierEaseInOut,
                    '--border-radius': borderRadius,
                    '--border': border,
                    '--close-color': closeColor,
                    '--close-color-hover': closeColorHover,
                    '--close-color-pressed': closeColorPressed,
                    '--close-margin': closeMargin,
                    '--close-size': closeSize,
                    '--color': color,
                    '--color-checkable': colorCheckable,
                    '--color-checked': colorChecked,
                    '--color-checked-hover': colorCheckedHover,
                    '--color-checked-pressed': colorCheckedPressed,
                    '--color-hover-checkable': colorHoverCheckable,
                    '--color-pressed-checkable': colorPressedCheckable,
                    '--font-size': fontSize,
                    '--height': height,
                    '--opacity-disabled': opacityDisabled,
                    '--padding': padding,
                    '--text-color': textColor,
                    '--text-color-checkable': textColorCheckable,
                    '--text-color-checked': textColorChecked,
                    '--text-color-hover-checkable': textColorHoverCheckable,
                    '--text-color-pressed-checkable': textColorPressedCheckable
                };
            }) });
    },
    render() {
        const { mergedClsPrefix } = this;
        return (h("div", { class: [
                `${mergedClsPrefix}-tag`,
                {
                    [`${mergedClsPrefix}-tag--disabled`]: this.disabled,
                    [`${mergedClsPrefix}-tag--checkable`]: this.checkable,
                    [`${mergedClsPrefix}-tag--checked`]: this.checkable && this.checked,
                    [`${mergedClsPrefix}-tag--round`]: this.round
                }
            ], style: this.cssVars, onClick: this.handleClick, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave },
            h("span", { class: `${mergedClsPrefix}-tag__content`, ref: "contentRef" }, this.$slots),
            !this.checkable && this.closable ? (h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-tag__close`, disabled: this.disabled, onClick: this.handleCloseClick })) : null,
            !this.checkable && this.mergedBordered ? (h("div", { class: `${mergedClsPrefix}-tag__border` })) : null));
    }
});
