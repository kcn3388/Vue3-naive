"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vue_1 = require("vue");
const SelectMenu_1 = require("./SelectMenu");
const vooks_1 = require("vooks");
const icons_1 = require("../../icons");
const icon_1 = require("../../icon");
const checkMarkIcon = vue_1.h(icons_1.CheckmarkIcon);
function renderCheckMark(show, clsPrefix) {
    return (vue_1.h(vue_1.Transition, { name: "fade-in-scale-up-transition" }, {
        default: () => show ? (vue_1.h(icon_1.default, { clsPrefix: clsPrefix, class: `${clsPrefix}-base-select-option__check` }, {
            default: () => checkMarkIcon
        })) : null
    }));
}
exports.default = vue_1.defineComponent({
    name: 'NBaseSelectOption',
    props: {
        clsPrefix: {
            type: String,
            required: true
        },
        tmNode: {
            type: Object,
            required: true
        }
    },
    setup(props) {
        const { valueRef, pendingTmNodeRef, multipleRef, valueSetRef, handleOptionClick, handleOptionMouseEnter
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
         } = vue_1.inject(SelectMenu_1.internalSelectionMenuInjectionKey);
        const rawNodeRef = vue_1.toRef(props.tmNode, 'rawNode');
        const isPendingRef = vooks_1.useMemo(() => {
            const { value: pendingTmNode } = pendingTmNodeRef;
            if (!pendingTmNode)
                return false;
            return props.tmNode.key === pendingTmNode.key;
        });
        function handleClick(e) {
            const { tmNode } = props;
            if (tmNode.disabled)
                return;
            handleOptionClick(e, tmNode);
        }
        function handleMouseEnter(e) {
            const { tmNode } = props;
            if (tmNode.disabled)
                return;
            handleOptionMouseEnter(e, tmNode);
        }
        function handleMouseMove(e) {
            const { tmNode } = props;
            const { value: isPending } = isPendingRef;
            if (tmNode.disabled || isPending)
                return;
            handleOptionMouseEnter(e, tmNode);
        }
        return {
            multiple: multipleRef,
            rawNode: rawNodeRef,
            isGrouped: vooks_1.useMemo(() => {
                const { tmNode } = props;
                const { parent } = tmNode;
                return parent && parent.rawNode.type === 'group';
            }),
            isPending: isPendingRef,
            isSelected: vooks_1.useMemo(() => {
                const { value } = valueRef;
                const { value: multiple } = multipleRef;
                if (value === null)
                    return false;
                const optionValue = rawNodeRef.value.value;
                if (multiple) {
                    const { value: valueSet } = valueSetRef;
                    return valueSet.has(optionValue);
                }
                else {
                    return value === optionValue;
                }
            }),
            handleMouseMove,
            handleMouseEnter,
            handleClick
        };
    },
    render() {
        const { clsPrefix, rawNode, isSelected, isPending, isGrouped, multiple, handleClick, handleMouseEnter, handleMouseMove } = this;
        const showCheckMark = multiple && isSelected;
        const children = rawNode.render
            ? [
                rawNode.render(rawNode, isSelected),
                renderCheckMark(showCheckMark, clsPrefix)
            ]
            : [rawNode.label, renderCheckMark(showCheckMark, clsPrefix)];
        return (vue_1.h("div", { class: [
                `${clsPrefix}-base-select-option`,
                rawNode.class,
                {
                    [`${clsPrefix}-base-select-option--disabled`]: rawNode.disabled,
                    [`${clsPrefix}-base-select-option--selected`]: isSelected,
                    [`${clsPrefix}-base-select-option--grouped`]: isGrouped,
                    [`${clsPrefix}-base-select-option--pending`]: isPending
                }
            ], style: rawNode.style, onClick: handleClick, onMouseenter: handleMouseEnter, onMousemove: handleMouseMove }, children));
    }
});
